<?xml version="1.0" encoding="utf-8"?>
<events:EventDispatcher xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:events="flash.events.*" xmlns:ns="AfcsNameSpace" xmlns:adapt="bombs.adapt.*" xmlns:shared="bombs.model.shared.*" xmlns:model="bombs.model.*" xmlns:util="bombs.util.*" xmlns:sharedModel="com.adobe.rtc.sharedModel.*">

	<mx:Script>
		<![CDATA[
			import bombs.util.CharacterTimer;
			import com.adobe.rtc.events.SessionEvent;
			import com.adobe.rtc.events.CollectionNodeEvent;
			import bombs.util.BombTimer;
			import bombs.model.Bomb;
			import bombs.util.SimpleListEvent;
			import com.adobe.rtc.sharedModel.SharedProperty;
			import com.adobe.rtc.events.SharedPropertyEvent;
			import bombs.model.Character;
			import mx.events.CollectionEventKind;
			import mx.events.CollectionEvent;
			
			// CONSTS // 
			public static const ROOM:String = "http://connectnow.acrobat.com/seanhessnet/game2";
			public static const USER:String = "seanhess@gmail.com";
			public static const PASS:String = "cocomo";
			
			public static const CHARACTER_SIZE:int = 20;
			public static const BLAST_RADIUS:int = 20;
			
			[Bindable] public var playing:Boolean = false;
			[Bindable] public var mainCharacter:Character;
			[Bindable] public var dead:Boolean = false;
			
			[Bindable] public var highscore:Character;
			
			private var activeCharacters:Dictionary;
			
			public function connect():void
			{
				session.login();
				characters.subscribe();
				bombsList.subscribe();
				scoreProperty.subscribe();
				activeCharacters = new Dictionary(true);
			}
			
			public function startOver():void
			{
				dead = false;
				playing = false;
			}
			
			public function nuke():void
			{
				characters.removeAll();
				bombsList.removeAll();
			}
			
			public function joinGame(character:Character):void
			{
				trace("[ JOIN GAME ]");
				mainCharacter = character;
				playing = true;
				characters.add(mainCharacter);
			}
			
			public function startPlaying():void
			{
				playing = true;
			}
			
			public function move(x:int, y:int):void
			{
				if (!playing) return;
				
				trace("[ MOVE ] " + x + " " + y);
				mainCharacter.destinationX = x;
				mainCharacter.destinationY = y;
				update();	
			}
			
			/**
			 * updates the main char on the server
			 */
			public function update():void
			{
				if (!playing) return;
				trace("[ UPDATE -> ] ");
				characters.update(mainCharacter);
			}
			
			public function lay():void
			{
				if (!playing) return;
								
				if (mainCharacter.bombs < 1)
					return;
				
				trace("[ LAY BOMB -> ] ");
				
				mainCharacter.bombs--;
				
				var bomb:Bomb = new Bomb();
					bomb.locationX = mainCharacter.locationX;
					bomb.locationY = mainCharacter.locationY;
					bomb.owner = mainCharacter.name;
					
				bombsList.add(bomb);
			}
			
			protected function checkActivity(char:Character):void
			{
				if (activeCharacters[char] == null)
				{
					var timer:CharacterTimer = new CharacterTimer();
						timer.checkInactivity(char);
						timer.addEventListener(CharacterTimer.INACTIVE, onInactive);
					
					activeCharacters[char] = timer; 
				}
				else
				{
					var timer:CharacterTimer = activeCharacters[char];
					timer.active();
				}
			}
			
			protected function onInactive(event:Event):void
			{
				var timer:CharacterTimer = event.target as CharacterTimer;
					timer.removeEventListener(CharacterTimer.INACTIVE, onInactive);
					
				if (!playing) return;
					
				var char:Character = timer.char;

				if (char == mainCharacter)
				{
					playing = false;
					dead = true;
				}

				characters.remove(char);
				delete activeCharacters[char];
			}
			
			protected function updateChar(event:SimpleListEvent):void
			{
				if (!playing) return;
				
				var char:Character = event.item as Character;
				var update:Object = event.update;
				
				checkActivity(char);
				
				if (!mainCharacter || char.name != mainCharacter.name)
				{
					char.destinationX = update.destinationX;
					char.destinationY = update.destinationY;
				}
				
				char.radius = update.radius;
				char.avatar = update.avatar;
				char.kills = update.kills;
				
				trace("[ UPDATE CHAR <- ] " + char.name + " k" + char.kills + " r" + char.radius + " x" + char.destinationX + " y" + char.destinationY);

				if (mainCharacter && char.name == mainCharacter.name && char != mainCharacter)
				{
					trace(" - replacing main");
					char.avatar = mainCharacter.avatar;
					mainCharacter = char;
				}
			}
			
			/**
			 * Called when a bomb is added to the list. Lets us set up
			 * the timer. 
			 */
			protected function updateBomb(event:SimpleListEvent):void
			{
				if (!playing) return;
				
				trace("[ UPDATE BOMB <- ] ");

				var bomb:Bomb = event.item as Bomb;
				var update:Object = event.update;
				
				bomb.locationX = update.locationX;
				bomb.locationY = update.locationY;
				bomb.blastRadius = update.blastRadius;
				bomb.fuse = update.fuse;
				bomb.owner = update.owner;
				
				var timer:BombTimer = new BombTimer();
					timer.countDown(bomb);
					timer.addEventListener(BombTimer.EXPLODE, onExplode);
			}

			/**
			 * Removes the bomb from the list, and if you are
			 * the owner, checks to see if you've killed anyone
			 */
			protected function onExplode(event:Event):void
			{
				trace("[ EXPLODE ] ");

				var timer:BombTimer = event.target as BombTimer;
					timer.removeEventListener(BombTimer.EXPLODE, onExplode);
					timer.addEventListener(BombTimer.DONE_EXPLODING, onDoneExploding);

				var bomb:Bomb = timer.bomb;
				
				if (bomb.owner == mainCharacter.name)
				{
					mainCharacter.bombs++;
					update();					
				}
				
				if (bomb.space.intersects(mainCharacter.space))
				{
					// then you is dead! // 
					trace(" - died ");
					
					mainCharacter.dead = true;
					characters.remove(mainCharacter);
					
					var owner:String = bomb.owner;
					
					if (owner != mainCharacter.name)
					{
						var killer:Character = characters.items[owner];
							killer.kills++;
							killer.radius += 5;
							
						if (!highscore || killer.kills > highscore.kills)
							scoreProperty.value = killer;
							
						characters.update(killer);
					}
					
					playing = false;
					dead = true;
				}
				
				bombsList.remove(bomb); // so, EVERYONE is removing the bombs redundantly. This is ignored, but it keeps the thing clean
				timer.countExplosion(bomb);
			}
			
			/**
			 * Tell the list to issue an event saying it's ok to 
			 * remove the renderer
			 */
			protected function onDoneExploding(event:Event):void
			{
				var timer:BombTimer = event.target as BombTimer;
					timer.removeEventListener(BombTimer.DONE_EXPLODING, onDoneExploding);
					
				var bomb:Bomb = timer.bomb;
				bombsList.bombDoneExploding(bomb);
			}
			
			protected function onHighScoreChange(event:SharedPropertyEvent):void
			{
				if (scoreProperty.value == null)
					return;
				
				var highScoreCharacter:Character = new Character();
				highScoreCharacter.name = scoreProperty.value.name;
				highScoreCharacter.kills = scoreProperty.value.kills;
				
				highscore = highScoreCharacter;
			}
		]]>
	</mx:Script>

	<!-- Auth -->	
	<ns:AdobeHSAuthenticator id="auth" userName="{USER}" password="{PASS}"/>
	<ns:LocalAuthenticator id="local"/>

	<!-- Session -->
	<ns:ConnectSession id="session" authenticator="{local}" roomURL="{ROOM}"/>
	
	<!-- Sharing -->
	<util:SimpleSharedList id="characters" 
		session="{session}" 
		idField="name"
		itemType="{Character}"
		sharedID="characters"
		receive="updateChar(event)"
	/>
	
	<util:SharedBombList id="bombsList" 
		session="{session}" 
		idField="id"
		itemType="{Bomb}"
		sharedID="bombs"
		receive="updateBomb(event)"
	/>
	
	<sharedModel:SharedProperty id="scoreProperty"
		connectSession="{session}"
		sharedID="highscore"
		nodeName="character"
		change="onHighScoreChange(event)"
	/>

</events:EventDispatcher>